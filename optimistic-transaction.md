---
title: TiDB Optimistic Transaction Model
summary: TiDB の楽観的トランザクション モデルについて学習します。
---

# TiDB 楽観的トランザクションモデル {#tidb-optimistic-transaction-model}

楽観的トランザクションでは、競合する変更はトランザクションのコミット時に検出されます。これにより、同時トランザクションが同じ行を頻繁に変更しない場合、行ロックの取得プロセスを省略できるため、パフォーマンスが向上します。同時トランザクションが同じ行を頻繁に変更する場合（競合）、楽観的トランザクションのパフォーマンスは[悲観的取引](/pessimistic-transaction.md)よりも低下する可能性があります。

楽観的トランザクションを有効にする前に、アプリケーションが`COMMIT`文でエラーが返される可能性があることを正しく処理できることを確認してください。アプリケーションがこれをどのように処理するか不明な場合は、代わりに悲観的トランザクションを使用することをお勧めします。

> **注記：**
>
> v3.0.8以降、TiDBはデフォルトで[悲観的トランザクションモード](/pessimistic-transaction.md)使用します。ただし、既存のクラスターをv3.0.7以前からv3.0.8以降にアップグレードした場合、これは影響を受けません。つまり、**新しく作成されたクラスターのみがデフォルトで悲観的トランザクションモードを使用します**。

## 楽観的取引の原則 {#principles-of-optimistic-transactions}

分散トランザクションをサポートするために、TiDBは楽観的トランザクションにおいて2相コミット（2PC）を採用しています。手順は以下のとおりです。

![2PC in TiDB](/media/2pc-in-tidb.png)

1.  クライアントがトランザクションを開始します。

    TiDBはPDからタイムスタンプ（時間的に単調増加し、グローバルに一意）を取得し、これを現在のトランザクションの一意のトランザクションID `start_ts` ）として取得します。TiDBはマルチバージョン同時実行制御を実装しているため、 `start_ts`このトランザクションによって取得されたデータベーススナップショットのバージョンとしても機能します。つまり、このトランザクションはデータベースから`start_ts`時点のデータのみを読み取ることができます。

2.  クライアントは読み取り要求を発行します。

    1.  TiDB は PD からルーティング情報 (TiKV ノード間でデータがどのように分散されるか) を受信します。
    2.  TiDB は TiKV からバージョン`start_ts`のデータを受け取ります。

3.  クライアントが書き込み要求を発行します。

    TiDBは、書き込まれたデータが制約を満たしているかどうかを確認します（データ型が正しいことを確認するために、NOT NULL制約が満たされます）。**有効なデータは、TiDB内のこのトランザクションのプライベートメモリに保存されます**。

4.  クライアントはコミット要求を発行します。

5.  TiDB は 2PC を開始し、トランザクションの原子性を保証しながらデータをストアに保持します。

    1.  TiDB は書き込むデータから主キーを選択します。
    2.  TiDB は PD からリージョン分布の情報を受け取り、それに応じてすべてのキーをリージョンごとにグループ化します。
    3.  TiDBは関係するすべてのTiKVノードに事前書き込み要求を送信します。その後、TiKVは競合バージョンや期限切れバージョンの有無を確認します。有効なデータはロックされます。
    4.  TiDB は事前書き込みフェーズですべての応答を受信し、事前書き込みは成功します。
    5.  TiDB は PD からコミット バージョン番号を受け取り、それを`commit_ts`としてマークします。
    6.  TiDBは、主キーが配置されているTiKVノードへの2番目のコミットを開始します。TiKVはデータをチェックし、書き込み前のフェーズで残されたロックを解除します。
    7.  TiDB は、第 2 フェーズが正常に終了したことを報告するメッセージを受信します。

6.  TiDB は、トランザクションが正常にコミットされたことをクライアントに通知するメッセージを返します。

7.  TiDB は、このトランザクションに残っているロックを非同期的に消去します。

## メリットとデメリット {#advantages-and-disadvantages}

上記の TiDB のトランザクションのプロセスから、TiDB トランザクションには次の利点があることがわかります。

-   簡単に理解できる
-   単一行トランザクションに基づくクロスノードトランザクションを実装する
-   分散型ロック管理

ただし、TiDB トランザクションには次のような欠点もあります。

-   2PCによるトランザクションレイテンシー
-   集中化されたタイムスタンプ割り当てサービスが必要
-   メモリに大量のデータが書き込まれるとOOM（メモリ不足）が発生する

## トランザクションの再試行 {#transaction-retries}

> **注記：**
>
> バージョン8.0.0以降、 [`tidb_disable_txn_auto_retry`](/system-variables.md#tidb_disable_txn_auto_retry)システム変数は非推奨となり、TiDBは楽観的トランザクションの自動再試行をサポートしなくなりました。 [悲観的なトランザクションモード](/pessimistic-transaction.md)使用をお勧めします。楽観的ミスティックトランザクションの競合が発生した場合は、エラーをキャプチャしてアプリケーション内でトランザクションを再試行できます。

楽観的トランザクションモデルでは、競合が激しいシナリオでは、書き込み-書き込み競合によりトランザクションがコミットに失敗する可能性があります。v3.0.8以降、TiDBはMySQLと同様にデフォルトで[悲観的トランザクションモード](/pessimistic-transaction.md)使用します。つまり、TiDBとMySQLは書き込み型SQL文の実行中にロックを追加し、繰り返し読み取り分離レベルによって現在の読み取りが許容されるため、コミットで例外が発生することはありません。

### 自動再試行 {#automatic-retry}

> **注記：**
>
> -   TiDB v3.0.0 以降では、**トランザクションの分離レベルが破られる**可能性があるため、トランザクションの自動再試行はデフォルトで無効になっています。
> -   TiDB v8.0.0 以降では、楽観的トランザクションの自動再試行はサポートされなくなりました。

トランザクションのコミット中に書き込み競合が発生した場合、TiDBは書き込み操作を含むSQL文を自動的に再試行します。自動再試行を有効にするには`tidb_disable_txn_auto_retry`を`OFF`に設定し、再試行回数の上限を設定するには`tidb_retry_limit`設定します。

```toml
# Whether to disable automatic retry. ("on" by default)
tidb_disable_txn_auto_retry = OFF
# Set the maximum number of the retires. ("10" by default)
# When "tidb_retry_limit = 0", automatic retry is completely disabled.
tidb_retry_limit = 10
```

自動再試行は、セッション レベルまたはグローバル レベルのいずれかで有効にできます。

1.  セッションレベル:

    ```sql
    SET tidb_disable_txn_auto_retry = OFF;
    ```

    ```sql
    SET tidb_retry_limit = 10;
    ```

2.  グローバルレベル:

    ```sql
    SET GLOBAL tidb_disable_txn_auto_retry = OFF;
    ```

    ```sql
    SET GLOBAL tidb_retry_limit = 10;
    ```

> **注記：**
>
> `tidb_retry_limit`変数は再試行の最大回数を決定します。この変数を`0`に設定すると、自動的にコミットされる暗黙的な単一ステートメントトランザクションを含め、すべてのトランザクションが自動的に再試行されることはありません。これは、TiDBの自動再試行メカニズムを完全に無効化する方法です。自動再試行が無効化されると、競合するすべてのトランザクションは、失敗（ `try again later`メッセージを含む）を最速の方法でアプリケーションレイヤーに報告します。

### 再試行の制限 {#limits-of-retry}

デフォルトでは、TiDB はトランザクションを再試行しません。再試行すると、更新が失われ、 [`REPEATABLE READ`分離](/transaction-isolation-levels.md)破損する可能性があるためです。

理由は再試行の手順からわかります。

1.  新しいタイムスタンプを割り当て、それを`start_ts`としてマークします。
2.  書き込み操作を含む SQL ステートメントを再試行します。
3.  2 フェーズ コミットを実装します。

ステップ2では、TiDBは書き込み操作を含むSQL文のみを再試行します。ただし、再試行中に、TiDBはトランザクションの開始を示す新しいバージョン番号を受け取ります。つまり、TiDBは新しいバージョン`start_ts`のデータを使用してSQL文を再試行します。この場合、トランザクションが他のクエリ結果を使用してデータを更新すると、ステップ`REPEATABLE READ`分離性に違反するため、結果に不整合が生じる可能性があります。

アプリケーションが更新の損失を許容でき、 `REPEATABLE READ`分離一貫性を必要としない場合は、 `tidb_disable_txn_auto_retry = OFF`設定することでこの機能を有効にできます。

## 競合検出 {#conflict-detection}

分散データベースであるTiDBは、主に書き込み前のフェーズにおいて、TiKVレイヤーでメモリ内競合検出を実行します。TiDBインスタンスはステートレスであり、互いを認識しないため、自身の書き込みがクラスタ全体で競合を引き起こすかどうかを認識できません。そのため、競合検出はTiKVレイヤーで実行されます。

構成は次のとおりです。

```toml
# Controls the number of slots. ("2048000" by default）
scheduler-concurrency = 2048000
```

さらに、TiKV はスケジューラ内のラッチの待機に費やされた時間の監視をサポートします。

![Scheduler latch wait duration](/media/optimistic-transaction-metric.png)

`Scheduler latch wait duration`が高く、遅い書き込みがない場合、現時点では書き込みの競合が多く発生していると安全に結論付けることができます。
