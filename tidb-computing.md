---
title: TiDB Computing
summary: TiDBは、TiKVの分散storageを利用して、トランザクション処理とデータ分析を組み合わせたコンピューティングエンジンを構築します。テーブルデータとインデックス付きデータを(Key, Value)のペアにマッピングし、メタデータを管理します。SQLレイヤーは、SQLステートメントをKey-Value操作に変換し、TiKVから結果を取得します。
---

# TiDB コンピューティング {#tidb-computing}

TiKV が提供する分散storageに基づいて、TiDB は、トランザクション処理の優れた機能とデータ分析の機能を組み合わせたコンピューティング エンジンを構築します。このドキュメントは、TiDB データベース テーブルのデータを TiKV の (Key, Value) キーと値のペアにマッピングするデータ マッピング アルゴリズムを紹介することから始まり、次に TiDB がメタデータを管理する方法を紹介し、最後にTiDB SQLレイヤーのアーキテクチャを説明します。

コンピューティングレイヤーが依存するstorageソリューションについては、このドキュメントでは TiKV の行ベースのstorage構造のみを紹介します。 OLAP サービスの場合、TiDB は TiKV 拡張機能として列ベースのstorageソリューション[TiFlash](/tiflash/tiflash-overview.md)を導入します。

## テーブルデータの Key-Value へのマッピング {#mapping-table-data-to-key-value}

このセクションでは、TiDB でデータを (Key, Value) キーと値のペアにマッピングするスキームについて説明します。ここでマッピングするデータには以下の2種類が含まれます。

-   テーブル内の各行のデータ。以下、テーブルデータと呼びます。
-   テーブル内のすべてのインデックスのデータ。以下、インデックスデータと呼びます。

### テーブルデータの Key-Value へのマッピング {#mapping-of-table-data-to-key-value}

リレーショナル データベースでは、テーブルに多くの列が含まれる場合があります。行内の各列のデータを (Key, Value) キーと値のペアにマップするには、キーの構築方法を検討する必要があります。まず、OLTP シナリオでは、単一行または複数行のデータの追加、削除、変更、検索などの多くの操作があり、データベースがデータ行を迅速に読み取る必要があります。したがって、各キーには、すばやく見つけられるように一意の ID (明示的または暗黙的) が必要です。さらに、多くの OLAP クエリではテーブル全体のスキャンが必要になります。テーブル内のすべての行のキーを範囲にエンコードできれば、テーブル全体を範囲クエリで効率的にスキャンできます。

上記の考慮事項に基づいて、TiDB でのテーブル データの Key-Value へのマッピングは次のように設計されています。

-   同じテーブルのデータが簡単に検索できるようにまとめて保持されるようにするために、TiDB は`TableID`で表される各テーブルにテーブル ID を割り当てます。テーブル ID は、クラスター全体で一意の整数です。
-   TiDB は、テーブル内のデータの各行に`RowID`で表される行 ID を割り当てます。行 ID も整数であり、テーブル内で一意です。行 ID に関して、TiDB は小さな最適化を行いました。テーブルに整数型の主キーがある場合、TiDB はこの主キーの値を行 ID として使用します。

データの各行は、次のルールに従って (Key, Value) キーと値のペアとしてエンコードされます。

    Key:   tablePrefix{TableID}_recordPrefixSep{RowID}
    Value: [col1, col2, col3, col4]

`tablePrefix`と`recordPrefixSep`両方とも、キー空間内の他のデータを区別するために使用される特別な文字列定数です。文字列定数の正確な値は[マッピング関係の概要](#summary-of-mapping-relationships)で紹介されています。

### インデックス付きデータの Key-Value へのマッピング {#mapping-of-indexed-data-to-key-value}

TiDB は、主キーと副次インデックス (一意のインデックスと非一意のインデックスの両方) の両方をサポートします。テーブル データ マッピング スキームと同様に、TiDB は`IndexID`で表されるテーブルの各インデックスにインデックス ID を割り当てます。

主キーと一意のインデックスの場合、キーと値のペアに基づいて対応する`RowID`すばやく見つける必要があるため、そのようなキーと値のペアは次のようにエンコードされます。

    Key:   tablePrefix{tableID}_indexPrefixSep{indexID}_indexedColumnsValue
    Value: RowID

一意性制約を満たす必要のない通常のセカンダリ インデックスの場合、1 つのキーが複数の行に対応する可能性があります。キーの範囲に応じて、対応する`RowID`クエリする必要があります。したがって、キーと値のペアは次の規則に従ってエンコードする必要があります。

    Key:   tablePrefix{TableID}_indexPrefixSep{IndexID}_indexedColumnsValue_{RowID}
    Value: null

### マッピング関係の概要 {#summary-of-mapping-relationships}

上記のすべてのエンコード規則の`tablePrefix` 、 `recordPrefixSep` 、および`indexPrefixSep`は、KV をキー空間内の他のデータから区別するために使用される文字列定数であり、次のように定義されます。

    tablePrefix     = []byte{'t'}
    recordPrefixSep = []byte{'r'}
    indexPrefixSep  = []byte{'i'}

また、上記のエンコード スキームでは、テーブル データまたはインデックス データ キーのエンコード スキームに関係なく、テーブル内のすべての行が同じキー プレフィックスを持ち、インデックスのすべてのデータも同じプレフィックスを持つことに注意してください。このようにして、同じプレフィックスを持つデータが TiKV のキー空間にまとめて配置されます。したがって、エンコード前とエンコード後の比較が同じになるようにサフィックス部分のエンコード方式を慎重に設計することで、テーブル データまたはインデックス データを順序どおりに TiKV に保存できます。このエンコーディング スキームを使用すると、テーブル内のすべての行データが TiKV のキー空間に`RowID`ずつ順番に配置され、特定のインデックスのデータもインデックス データの特定の値に従ってキー空間に順番に配置されます ( `indexedColumnsValue` )。

### Key-Value マッピング関係の例 {#example-of-key-value-mapping-relationship}

このセクションでは、TiDB の Key-Value マッピング関係を理解するための簡単な例を示します。 TiDB に次のテーブルが存在するとします。

```sql
CREATE TABLE User (
     ID int,
     Name varchar(20),
     Role varchar(20),
     Age int,
     PRIMARY KEY (ID),
     KEY idxAge (Age)
);
```

テーブルに 3 行のデータがあるとします。

    1, "TiDB", "SQL Layer", 10
    2, "TiKV", "KV Engine", 20
    3, "PD", "Manager", 30

データの各行は (Key, Value) キーと値のペアにマップされ、テーブルには`int`種類の主キーがあるため、値`RowID`がこの主キーの値になります。テーブルの`TableID` `10`で、TiKV に保存されるテーブル データは次のようになるとします。

    t10_r1 --> ["TiDB", "SQL  Layer", 10]
    t10_r2 --> ["TiKV", "KV  Engine", 20]
    t10_r3 --> ["PD", " Manager", 30]

主キーに加えて、テーブルには非一意の通常の副次インデックス`idxAge`があります。 `IndexID`が`1`であると仮定すると、TiKV に保存されるインデックス データは次のようになります。

    t10_i1_10_1 --> null
    t10_i1_20_2 --> null
    t10_i1_30_3 --> null

上の例は、TiDB におけるリレーショナル モデルから Key-Value モデルへのマッピング ルールと、このマッピング スキームの背後にある考慮事項を示しています。

## メタデータ管理 {#metadata-management}

TiDB の各データベースとテーブルには、その定義とさまざまな属性を示すメタデータがあります。この情報も永続化する必要があり、TiDB はこの情報を TiKV にも保存します。

各データベースまたはテーブルには一意の ID が割り当てられます。一意の識別子として、テーブル データが Key-Value にエンコードされる場合、この ID は`m_`というプレフィックスを付けて Key にエンコードされます。これにより、格納されているシリアル化されたメタデータを使用してキーと値のペアが構築されます。

さらに、TiDB は、専用の (Key, Value) キーと値のペアを使用して、すべてのテーブルの構造情報の最新バージョン番号を保存します。このキーと値のペアはグローバルであり、DDL 操作の状態が変化するたびにバージョン番号が`1`ずつ増加します。 TiDB は、このキーと値のペアを`/tidb/ddl/global_schema_version`というキーを使用して PDサーバーに永続的に保存します。 Value は`int64`タイプのバージョン番号の値です。一方、TiDB はスキーマ変更をオンラインで適用するため、PDサーバーに格納されているテーブル構造情報のバージョン番号が変更されているかどうかを常にチェックするバックグラウンド スレッドを保持します。このスレッドは、バージョンの変更を一定期間内に取得できることも保証します。

## SQLレイヤーの概要 {#sql-layer-overview}

TiDB の SQLレイヤーTiDB サーバーは、SQL ステートメントを Key-Value オペレーションに変換し、そのオペレーションを分散 Key-Valuestorageレイヤーである TiKV に転送し、TiKV から返された結果を組み立てて、最後にクエリ結果をクライアントに返します。

このレイヤーのノードはステートレスです。これらのノード自体はデータを保存せず、完全に同等です。

### SQLコンピューティング {#sql-computing}

SQL コンピューティングの最も単純なソリューションは、前のセクションで説明した[テーブルデータの Key-Value へのマッピング](#mapping-of-table-data-to-key-value)です。これは、SQL クエリを KV クエリにマップし、KV インターフェイスを通じて対応するデータを取得し、さまざまな計算を実行します。

たとえば、 `select count(*) from user where name = "TiDB"` SQL ステートメントを実行するには、TiDB はテーブル内のすべてのデータを読み取り、 `name`フィールドが`TiDB`であるかどうかを確認し、そうであればこの行を返します。プロセスは次のとおりです。

1.  キー範囲を作成します。テーブル内のすべての`RowID`は`[0, MaxInt64)`範囲にあります。行データ`Key`エンコード規則に従って、 `0`と`MaxInt64`を使用すると、左が閉じて右が開く`[StartKey, EndKey)`範囲を構築できます。
2.  スキャン キー範囲: 上記で構築されたキー範囲に従って TiKV 内のデータを読み取ります。
3.  データのフィルター: 読み取られたデータの各行に対して、 `name = "TiDB"`の式を計算します。結果が`true`場合は、この行に戻ります。そうでない場合は、この行をスキップしてください。
4.  `Count(*)`を計算します。要件を満たす各行について、結果を`Count(*)`に加算します。

**プロセス全体を次のように図示します。**

![naive sql flow](/media/tidb-computing-native-sql-flow.jpeg)

このソリューションは直感的で実現可能ですが、分散データベースのシナリオでは明らかな問題がいくつかあります。

-   データのスキャン中に、少なくとも 1 つの RPC オーバーヘッドを伴う KV 操作を介して TiKV から各行が読み取られます。スキャンするデータが大量にある場合、このオーバーヘッドは非常に高くなる可能性があります。
-   すべての行に適用できるわけではありません。条件を満たさないデータは読み出す必要はありません。
-   このクエリの返された結果から、必要なのは、それらの行の値ではなく、要件に一致する行の数のみです。

### 分散SQL操作 {#distributed-sql-operations}

上記の問題を解決するには、多数の RPC 呼び出しを避けるために、計算をできるだけstorageノードの近くで行う必要があります。まず、SQL 述語条件`name = "TiDB"`を計算のためにstorageノードにプッシュダウンして、有効な行のみが返されるようにする必要があります。これにより、無意味なネットワーク転送が回避されます。次に、集約関数`Count(*)`事前集約のためにstorageノードにプッシュダウンすることもでき、各ノードは結果`Count(*)`を返すだけで済みます。 SQLレイヤーは、各ノードから返された`Count(*)`結果を合計します。

次の図は、データがレイヤーレイヤーにどのように返されるかを示しています。

![dist sql flow](/media/tidb-computing-dist-sql-flow.png)

### SQLレイヤーのアーキテクチャ {#architecture-of-sql-layer}

前のセクションでは、SQLレイヤーのいくつかの関数を紹介しました。SQL ステートメントがどのように処理されるかについての基本を理解していただければ幸いです。実際、TiDB の SQLレイヤーははるかに複雑で、多くのモジュールとレイヤーがあります。次の図は、重要なモジュールと呼び出し関係を示しています。

![tidb sql layer](/media/tidb-computing-tidb-sql-layer.png)

ユーザーの SQL リクエストは、直接または`Load Balancer`を介して TiDB サーバーに送信されます。 TiDB サーバーは`MySQL Protocol Packet`解析し、リクエストの内容を取得し、SQL リクエストを構文的および意味的に解析し、クエリ プランを開発および最適化し、クエリ プランを実行し、データを取得して処理します。すべてのデータは TiKV クラスターに保存されるため、このプロセスでは、TiDB サーバーが TiKV と対話してデータを取得する必要があります。最後に、TiDB サーバーはクエリ結果をユーザーに返す必要があります。
