---
title: Unique Serial Number Generation
summary: Unique serial number generation solution for developers who generate their own unique IDs.
---

# Unique Serial Number Generation

This page will introduce the unique serial number generation scheme to help developers who generate their own unique IDs.

## Auto Increment Column

`AUTO_INCREMENT` is an attribute of a column on most MySQL protocol-compliant RDBMSs that is configured to enable the database to automatically assign a value to the column without the user having to assign a value to the column, which automatically grows as the number of records in the table increases and ensures uniqueness. In most scenarios, auto-incrementing columns are used as proxy primary keys with no business meaning. The limitation of auto-incrementing columns is that they can only use integer fields, and the values assigned to them can only be integer. Assuming that the sequence number required by the business is made up of letters, numbers and other characters, it is difficult for the user to obtain the numeric values required in the sequence number through the auto-incrementing column.

## Sequence

A **Sequence** is a database object that can be invoked by an application to produce incremental sequence values. Applications can flexibly use the sequence values to assign values to one or more tables, or they can use the sequence values for more complex processing to achieve a combination of text and numbers to give some tracking and classification meaning to proxy keys. Sequence functionality is available starting with TiDB v4.0 release, please refer to [sequence documentation](https://docs.pingcap.com/zh/tidb/stable/sql-statement-create-sequence#create-sequence) for details.

## Snowflake like solutions

Snowflake 是 Twitter 提出的分布式 ID 生成方案。目前有多种实现，较流行的是百度的 uid-generator 和美团的 leaf。下面以 uid-generator 为例展开说明。

Snowflake is a distributed ID generation solution proposed by Twitter. There are several implementations, the more popular ones are Baidu's **uid-generator** and Meituan's **leaf**. **uid-generator** is used as an example.

The 64-bit ID structure generated by **uid-generator** is as follows:

```
| sign | delta seconds | worker node id | sequencs |
|------|---------------|----------------|----------|
| 1bit |     28bits    | 22bits         | 13bits   |
```

- sign: Fixed length of `1` bit. Fixed to `0` to indicate that the generated ID is always a positive number.
- delta seconds: default `28` bits. The current time, expressed as an incremental value in seconds relative to a preset time base (default `2016-05-20`). `28` bits can support up to about `8.7` years.
- worker node id: default `22` bits. Represents the machine id, usually obtained from a centralized ID generator when the application process is started. The default allocation policy is discard-as-you-go, and the process will reacquire a new worker node id on restart. 22 bits can support up to about `4.2 million` starts.
- sequence: default `13` bits. The sequence of concurrency per second, `13` bits can support `8192` concurrency per second.

## Number allocation solution

The number allocation scheme can be understood as bulk acquisition of self-incrementing IDs from the database, and this scheme requires a sequence number generation table, with each row representing a sequence object. A sample table definition is as follows:

| Field Name | Field Type | Field Description |
| -------- | ------------ | ---------------------------- |
| SEQ_NAME | varchar(128) | The name of the sequence, used to diffuse different operations |
| MAX_ID | bigint(20) | The maximum value of the current sequence that has been assigned out |
| STEP | int(11) | The step length, which indicates the length of each assigned segment |

The application gets a sequence number at each configured step and updates the database at the same time to persist the maximum value of the current sequence that has been allocated, then the sequence number processing and allocation can be completed in the application memory. After a number is exhausted, the application will get a new number, which effectively reduces the pressure on the database write. In practice, you can also adjust the step length to control the frequency of database record updates.

Finally, it should be noted that the IDs generated by the above two solutions are not random enough to be used as **primary keys** for TiDB tables directly. In practice, you can perform bit-reverse on the generated IDs to get a more random new ID.
