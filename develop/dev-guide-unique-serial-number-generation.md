---
title: Unique Serial Number Generation
summary: 独自の固有 ID を生成する開発者向けの固有シリアル番号生成ソリューション。
---

# 一意のシリアル番号の生成 {#unique-serial-number-generation}

このドキュメントでは、独自の一意の ID を生成する開発者を支援するために、一意のシリアル番号生成スキームを紹介します。

## 自動増分列 {#auto-increment-column}

`AUTO_INCREMENT`は、MySQLプロトコルと互換性のある多くのRDBMSの列属性です。2 属性を使用すると、データベースはユーザーの介入なしにこの列に自動的に値を割り当てることができます。テーブル内のレコード数が増加すると、この列の値は自動的に増加し、一意であることが保証されます。 `AUTO_INCREMENT`のシナリオでは、 `AUTO_INCREMENT`列は実際には意味を持たない代理主キーとして使用されます。

`AUTO_INCREMENT`列目の制限は、列が整数型でなければならず、割り当てられる値も整数でなければならないことです。アプリケーションで必要なシリアル番号が文字、数字、その他の記号で区切られている場合、ユーザーは`AUTO_INCREMENT`列目を通してシリアル番号に必要な自動増分番号を取得することが困難になります。

## シーケンス {#sequence}

**シーケンス**は、アプリケーションが呼び出して増分シーケンス値を生成することができるデータベースオブジェクトです。アプリケーションはシーケンス値を柔軟に利用して、1つまたは複数のテーブルに値を割り当てることができます。また、シーケンス値を使用して、テキストと数値の組み合わせを生成するなど、より複雑な処理も可能です。このアプローチにより、プロキシキーに追跡と分類の意味が与えられます。

シーケンスはTiDB v4.0以降で利用可能です。詳細は[シーケンスドキュメント](/sql-statements/sql-statement-create-sequence.md#create-sequence)を参照してください。

## スノーフレークのようなソリューション {#snowflake-like-solutions}

Snowflakeは、Twitterが提案する分散ID生成ソリューションです。実装は複数ありますが、特に有名なのはBaiduの**uid-generator**とMeituanの**leaf**です。このセクションでは`uid-generator`例として使用します。

`uid-generator`によって生成される 64 ビットの ID 構造は次のとおりです。

    | sign | delta seconds | worker node id | sequencs |
    |------|---------------|----------------|----------|
    | 1bit |     28bits    | 22bits         | 13bits   |

-   符号: 1ビットの固定長。生成されるIDが常に正の数であることを示すために`0`に固定されます。
-   デルタ秒：デフォルトは28ビット。現在の時刻を、あらかじめ設定されたタイムベース（デフォルトは`2016-05-20` ）に対する増分値（秒）で表します。28ビットでは最大約8.7年までサポートできます。
-   ワーカーノードID：デフォルトでは22ビット。マシンIDを表します。通常、アプリケーションプロセスの開始時に中央IDジェネレータから取得されます。一般的な中央IDジェネレータには、自動インクリメント列やZooKeeperなどがあります。デフォルトの割り当てポリシーは「discard-as-you-go（実行時に破棄）」で、プロセスは再起動時に新しいワーカーノードIDを再取得します。22ビットでは最大約420万回の起動をサポートできます。
-   シーケンス: デフォルトでは13ビット。1秒あたりの同時実行シーケンス数。13ビットでは1秒あたり8192の同時実行シーケンスをサポートできます。

## 番号割り当てソリューション {#number-allocation-solution}

番号割り当てソリューションは、データベースから自動増分IDを一括取得することを意味します。この方式では、各行がシーケンスオブジェクトを表すシーケンス番号生成テーブルが必要です。テーブル定義の例を以下に示します。

| フィールド名     | フィールドタイプ     | フィールドの説明                          |
| ---------- | ------------ | --------------------------------- |
| `SEQ_NAME` | varchar(128) | 異なるアプリケーションを区別するために使用されるシーケンスの名前。 |
| `MAX_ID`   | ビッグインテント     | 現在割り当てられているシーケンスの最大値。             |
| `STEP`     | 整数           | 割り当てられた各セグメントの長さを示すステップ。          |

アプリケーションは毎回、設定されたステップでシーケンス番号のセグメントを取得します。同時にデータベースを更新し、現在割り当てられているシーケンスの最大値を維持します。シーケンス番号の処理と割り当てはアプリケーションのメモリ内で完了します。シーケンス番号のセグメントが使い果たされると、アプリケーションは新しいシーケンス番号のセグメントを取得し、データベースへの書き込み負荷を効果的に軽減します。実際には、ステップを調整することでデータベース更新の頻度を制御することもできます。

最後に、上記の2つのソリューションで生成されたIDは、TiDBテーブルの**主キー**として直接使用できるほどランダムではないことに注意してください。実際には、生成されたIDのビット反転を実行することで、よりランダムな新しいIDを取得できます。例えば、ビット反転を実行すると、ID `00000010100101000001111010011100` `00111001011110000010100101000000`に、 `11111111111111111111111111111101` `10111111111111111111111111111111`になります。

## ヘルプが必要ですか? {#need-help}

<CustomContent platform="tidb">

[不和](https://discord.gg/DQZ2dy3cuc?utm_source=doc)または[スラック](https://slack.tidb.io/invite?team=tidb-community&#x26;channel=everyone&#x26;ref=pingcap-docs) 、あるいは[サポートチケットを送信する](/support.md)についてコミュニティに質問してください。

</CustomContent>

<CustomContent platform="tidb-cloud">

[不和](https://discord.gg/DQZ2dy3cuc?utm_source=doc)または[スラック](https://slack.tidb.io/invite?team=tidb-community&#x26;channel=everyone&#x26;ref=pingcap-docs) 、あるいは[サポートチケットを送信する](https://tidb.support.pingcap.com/)についてコミュニティに質問してください。

</CustomContent>
