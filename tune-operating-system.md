---
title: Tune Operating System Performance
summary: Learn how to tune the parameters of the operating system.
---

# オペレーティング システムのパフォーマンスを調整する {#tune-operating-system-performance}

このドキュメントでは、CentOS 7 の各サブシステムのチューニング方法を紹介します。

> **ノート：**
>
> -   CentOS 7 オペレーティング システムの既定の構成は、中程度のワークロードで実行されるほとんどのサービスに適しています。特定のサブシステムのパフォーマンスを調整すると、他のサブシステムに悪影響を及ぼす可能性があります。したがって、システムをチューニングする前に、すべてのユーザー データと構成情報をバックアップしてください。
> -   本番環境に適用する前に、テスト環境ですべての変更を完全にテストします。

## パフォーマンス分析方法 {#performance-analysis-methods}

システムのチューニングは、システム パフォーマンス分析の結果に基づいている必要があります。このセクションでは、パフォーマンス分析の一般的な方法を示します。

### 60秒で {#in-60-seconds}

[*60,000 ミリ秒での Linux パフォーマンス分析*](http://www.brendangregg.com/Articles/Netflix_Linux_Perf_Analysis_60s.pdf)は、著者のブレンダン グレッグと Netflix パフォーマンス エンジニアリング チームによって公開されています。使用するすべてのツールは、Linux の公式リリースから入手できます。次のリスト項目の出力を分析して、最も一般的なパフォーマンスの問題をトラブルシューティングできます。

-   `uptime`
-   `dmesg | tail`
-   `vmstat 1`
-   `mpstat -P ALL 1`
-   `pidstat 1`
-   `iostat -xz 1`
-   `free -m`
-   `sar -n DEV 1`
-   `sar -n TCP,ETCP 1`
-   `top`

詳細な使用方法については、対応する`man`説明を参照してください。

### パフォーマンス {#perf}

perf は Linux カーネルが提供する重要なパフォーマンス分析ツールであり、ハードウェア レベル (CPU/PMU、パフォーマンス監視ユニット) の機能とソフトウェアの機能 (ソフトウェア カウンター、トレース ポイント) をカバーしています。詳細な使用方法については、 [パフォーマンスの例](http://www.brendangregg.com/perf.html#Background)を参照してください。

### BCC/bpftrace {#bcc-bpftrace}

CentOS 7.6 以降、Linux カーネルは Berkeley Packet Filter (BPF) をサポートしています。したがって、適切なツールを選択して、 [60秒で](#in-60-seconds)の結果に基づいて詳細な分析を行うことができます。 perf/ftrace と比較して、BPF はプログラマビリティを提供し、パフォーマンスのオーバーヘッドを小さくします。 kprobe と比較して、BPF はより高いセキュリティを提供し、本番環境により適しています。 BCC ツールキットの詳細な使用方法については、 [BPF コンパイラ コレクション (BCC)](https://github.com/iovisor/bcc/blob/master/README.md)を参照してください。

## 性能調整 {#performance-tuning}

このセクションでは、分類されたカーネル サブシステムに基づくパフォーマンス チューニングを紹介します。

### CPU—周波数スケーリング {#cpu-frequency-scaling}

cpufreq は、CPU 周波数を動的に調整するモジュールです。 5つのモードをサポートしています。サービスのパフォーマンスを確保するには、パフォーマンス モードを選択し、CPU 周波数をサポートされている最高の動作周波数に動的に調整せずに固定します。この操作のコマンドは`cpupower frequency-set --governor performance`です。

### CPU—割り込みアフィニティ {#cpu-interrupt-affinity}

-   `irqbalance`サービスでオートバランスが実現できます。
-   手動バランス:
    -   割り込みのバランスをとる必要があるデバイスを特定します。 CentOS 7.5 以降、システムは、 `be2iscsi`ドライバーと NVMe 設定を使用するデバイスなど、特定のデバイスとそのドライバーに最適な割り込みアフィニティを自動的に構成します。このようなデバイスの割り込みアフィニティを手動で構成することはできなくなりました。
    -   その他のデバイスについては、チップのマニュアルを調べて、これらのデバイスが割り込みの分散をサポートしているかどうかを確認してください。
        -   そうでない場合、これらのデバイスのすべての割り込みは同じ CPU にルーティングされ、変更できません。
        -   その場合、 `smp_affinity`マスクを計算し、対応する構成ファイルを設定します。詳細は[カーネルドキュメント](https://www.kernel.org/doc/Documentation/IRQ-affinity.txt)を参照してください。

### NUMA CPU バインディング {#numa-cpu-binding}

Non-Uniform Memory Access (NUMA) ノード間でのメモリアクセスを可能な限り回避するには、スレッドの CPU アフィニティを設定して、スレッド/プロセスを特定の CPU コアにバインドできます。通常のプログラムでは、CPU バインドに`numactl`コマンドを使用できます。詳細な使用方法については、Linux のマニュアル ページを参照してください。ネットワーク インターフェイス カード (NIC) の割り込みについては、 [ネットワークを調整する](#network-tuning)を参照してください。

### メモリ - トランスペアレント ヒュージ ページ (THP) {#memory-transparent-huge-page-thp}

データベース アプリケーションに THP を使用することは**お**勧めしません。これは、データベースのメモリアクセス パターンが連続的ではなく疎であることが多いためです。高レベルのメモリ断片化が深刻な場合、THP ページが割り当てられると、より高いレイテンシーが発生します。 THP の直接圧縮が有効になっている場合、CPU 使用率が急増します。したがって、THP を無効にすることをお勧めします。

```shell
echo never > /sys/kernel/mm/transparent_hugepage/enabled
echo never > /sys/kernel/mm/transparent_hugepage/defrag
```

### メモリ - 仮想メモリパラメータ {#memory-virtual-memory-parameters}

-   `dirty_ratio`パーセンテージ比率。ダーティ ページ キャッシュの合計量が合計システムメモリのこのパーセンテージ比率に達すると、システムは`pdflush`オペレーションを使用してダーティ ページ キャッシュをディスクに書き込み始めます。デフォルト値の`dirty_ratio` 20% で、通常は調整する必要はありません。 NVMe デバイスなどの高性能 SSD の場合、この値を下げると、メモリ再利用の効率が向上します。
-   `dirty_background_ratio`パーセンテージ比率。ダーティ ページ キャッシュの合計量が合計システムメモリのこのパーセンテージ比率に達すると、システムはバックグラウンドでディスクへのダーティ ページ キャッシュの書き込みを開始します。デフォルト値の`dirty_background_ratio` 10% で、通常は調整する必要はありません。 NVMe デバイスなどの高性能 SSD の場合、低い値を設定すると、メモリ再利用の効率が向上します。

### ストレージとファイル システム {#storage-and-file-system}

コア I/O スタック リンクは長く、ファイル システムレイヤー、ブロック デバイスレイヤー、ドライバーレイヤーを含みます。

#### I/O スケジューラ {#i-o-scheduler}

I/O スケジューラは、storageデバイスで I/O 操作をいつ、どのくらい実行するかを決定します。 I/O エレベーターとも呼ばれます。 SSD デバイスの場合、I/O スケジューリング ポリシーを`noop`に設定することをお勧めします。

```shell
echo noop > /sys/block/${SSD_DEV_NAME}/queue/scheduler
```

#### フォーマット パラメータ - ブロック サイズ {#formatting-parameters-block-size}

ブロックは、ファイル システムの作業単位です。ブロック サイズは、1 つのブロックに格納できるデータ量を決定するため、毎回書き込みまたは読み取りを行うデータの最小量を決定します。

デフォルトのブロック サイズは、ほとんどのシナリオに適しています。ただし、ブロック サイズ (または複数のブロックのサイズ) が、通常、毎回読み書きされるデータ量と同じか、わずかに大きい場合は、ファイル システムのパフォーマンスが向上し、データのstorage効率が高くなります。小さなファイルは依然としてブロック全体を使用します。ファイルは複数のブロックに分散できますが、実行時のオーバーヘッドが増加します。

`mkfs`コマンドを使用してデバイスをフォーマットする場合、ファイル システム オプションの一部としてブロック サイズを指定します。ブロック サイズを指定するパラメータは、ファイル システムによって異なります。詳細については、 `man mkfs.ext4`使用など、対応する`mkfs`マニュアル ページを参照してください。

#### <code>mount</code>パラメータ {#code-mount-code-parameters}

`mount`コマンドで`noatime`オプションを有効にすると、ファイルの読み取り時にメタデータの更新が無効になります。 `nodiratime`動作が有効になっている場合、ディレクトリの読み取り時にメタデータの更新が無効になります。

### ネットワークのチューニング {#network-tuning}

ネットワーク サブシステムは、機密性の高い接続を備えたさまざまなパーツで構成されています。 CentOS 7 ネットワーク サブシステムは、ほとんどのワークロードで最高のパフォーマンスを提供するように設計されており、これらのワークロードのパフォーマンスを自動的に最適化します。したがって、通常、ネットワーク パフォーマンスを手動で調整する必要はありません。

通常、ネットワークの問題は、ハードウェアまたは関連デバイスの問題が原因で発生します。そのため、プロトコル スタックを調整する前に、ハードウェアの問題を除外してください。

ネットワーク スタックは大部分が自己最適化されていますが、ネットワーク パケット処理の次の側面がボトルネックになり、パフォーマンスに影響を与える可能性があります。

-   NIC ハードウェア キャッシュ: ハードウェア レベルでパケット損失を正しく観察するには、 `ethtool -S ${NIC_DEV_NAME}`コマンドを使用して`drops`フィールドを観察します。パケットロスが発生した場合、ハード/ソフト割り込みの処理速度がNICの受信速度に追いついていない可能性があります。受信バッファ サイズが上限より小さい場合は、RX バッファを増やしてパケット損失を回避することもできます。クエリ コマンドは`ethtool -g ${NIC_DEV_NAME}` 、変更コマンドは`ethtool -G ${NIC_DEV_NAME}`です。

-   ハードウェア割り込み: NIC が Receive-Side Scaling (RSS、マルチ NIC 受信とも呼ばれます) 機能をサポートしている場合は、 `/proc/interrupts` NIC 割り込みを観察します。割り込みが不均一な場合は、 [CPU—周波数スケーリング](#cpufrequency-scaling) 、 [CPU—割り込みアフィニティ](#cpuinterrupt-affinity) 、および[NUMA CPU バインディング](#numa-cpu-binding)を参照してください。 NIC が RSS をサポートしていない場合、または RSS の数が物理 CPU コアの数よりもはるかに少ない場合は、Receive Packet Steering (RPS、RSS のソフトウェア実装と見なすことができます) を構成し、RPS 拡張の Receive Flow Steering ( RFS)。詳細な設定については、 [カーネルドキュメント](https://www.kernel.org/doc/Documentation/networking/scaling.txt)参照してください。

-   ソフトウェア割り込み: `/proc/net/softnet_stat`の監視を観察します。 3 番目の列を除く他の列の値が増加している場合は、 `softirq`に対して`net.core.netdev_budget`または`net.core.dev_weight`の値を適切に調整して、より多くの CPU 時間を取得します。さらに、CPU 使用率を確認して、CPU を頻繁に使用しているタスクと最適化できるかどうかを判断する必要もあります。

-   アプリケーション ソケットの受信キュー: `ss -nmp`の`Resv-q`列を監視します。キューがいっぱいの場合は、アプリケーション ソケット キャッシュのサイズを増やすか、自動キャッシュ調整方法を使用することを検討してください。また、アプリケーションレイヤーのアーキテクチャを最適化し、ソケットの読み取り間隔を短縮できないか検討してください。

-   イーサネット フロー制御: NIC とスイッチがフロー制御機能をサポートしている場合、この機能を使用して、カーネルが NIC キュー内のデータを処理する時間を残し、NIC バッファ オーバーフローの問題を回避できます。

-   割り込みの結合: ハードウェア割り込みが頻繁すぎるとシステム パフォーマンスが低下し、ハードウェア割り込みが遅すぎるとパケット損失が発生します。新しい NIC は割り込み合体機能をサポートし、ドライバーがハードウェア割り込みの数を自動的に調整できるようにします。 `ethtool -c ${NIC_DEV_NAME}`を実行してチェックし、 `ethtool -C ${NIC_DEV_NAME}`を実行してこの機能を有効にすることができます。適応モードにより、NIC は割り込み合体を自動的に調整できます。このモードでは、ドライバーはトラフィック モードとカーネル受信モードをチェックし、合体設定をリアルタイムで評価してパケット損失を防ぎます。異なるブランドの NIC には、異なる機能とデフォルト構成があります。詳細は、NIC のマニュアルを参照してください。

-   アダプター キュー: プロトコル スタックを処理する前に、カーネルはこのキューを使用して、NIC が受信したデータをバッファーします。各 CPU には独自のバックログ キューがあります。このキューにキャッシュできるパケットの最大数は`netdev_max_backlog`です。 `/proc/net/softnet_stat`の 2 番目の列を確認します。行の 2 列目が増加し続ける場合は、CPU [row-1] キューがいっぱいで、データ パケットが失われていることを意味します。この問題を解決するには、引き続き`net.core.netdev_max_backlog`値を 2 倍にします。

-   送信キュー: 送信キューの長さの値によって、送信前にキューに入れることができるパケットの数が決まります。デフォルト値は`1000`で、10 Gbps には十分です。しかし、 `ip -s link`の出力から TX エラーの値を観察した場合は、それを 2 倍にすることができます: `ip link set dev ${NIC_DEV_NAME} txqueuelen 2000` 。

-   Driver: NIC ドライバーは通常、チューニング パラメーターを提供します。デバイスのハードウェア マニュアルとそのドライバのドキュメントを参照してください。
