---
title: Merge and Migrate Data from Sharded Tables in the Pessimistic Mode
summary: DM が悲観的モードでシャード テーブルからデータをマージおよび移行する方法を学習します。
---

# 悲観モードでシャードテーブルからデータをマージおよび移行する {#merge-and-migrate-data-from-sharded-tables-in-the-pessimistic-mode}

このドキュメントでは、データ移行（DM）の悲観的モード（デフォルトモード）で提供されるシャーディングサポート機能について説明します。この機能を使用すると、上流のMySQLまたはMariaDBインスタンスにある同じテーブルスキーマを持つテーブルのデータを、下流のTiDBにある同じテーブルにマージして移行できます。

## 制限 {#restrictions}

DM には、悲観的モードでのシャーディング DDL の使用に関する次の制限があります。

-   論理**シャーディング グループ**(1 つの同じダウンストリーム テーブルにマージおよび移行する必要があるすべてのシャード テーブルで構成) の場合、移行を実行するには、シャード テーブルのソースを正確に含む 1 つのタスクを使用するように制限されます。
-   論理**シャーディング グループ**では、上流のすべてのシャーディングされたテーブルで同じ DDL ステートメントを同じ順序で実行する必要があり (スキーマ名とテーブル名は異なる場合があります)、現在の DDL 操作が完全に終了しない限り次の DDL ステートメントは実行できません。
    -   例えば、 `column B`加算する前に`table_1`に`column A`加算した場合、 `column A`加算する前に`column B`に`table_2`を加算することはできません。DDL文を異なる順序で実行することはサポートされていません。
-   シャーディング グループでは、対応する DDL ステートメントをすべての上流のシャーディングされたテーブルで実行する必要があります。
    -   たとえば、 `DM-worker-2`に対応する 1 つ以上のアップストリーム シャード テーブルで DDL ステートメントが実行されない場合、DDL ステートメントを実行した他の DM ワーカーは移行タスクを一時停止し、 `DM-worker-2`アップストリーム DDL ステートメントを受信するまで待機します。
-   シャーディング グループ移行タスクは`DROP DATABASE` `DROP TABLE`していません。
    -   DM-worker の同期ユニットは`DROP TABLE` `DROP DATABASE`を自動的に無視します。
-   シャーディング グループ移行タスクは`TRUNCATE TABLE`サポートしていません。
    -   DM ワーカーの同期ユニットは、上流のシャード テーブルの`TRUNCATE TABLE`ステートメントを自動的に無視します。
-   シャーディング グループ移行タスクは`RENAME TABLE`サポートしますが、次の制限があります (オンライン DDL は別のソリューションでサポートされます)。
    -   テーブルの名前を変更できるのは、他のテーブルで使用されていない新しい名前だけです。
    -   1 つの`RENAME TABLE`ステートメントには、1 つの`RENAME`演算のみを含めることができます。
-   シャーディング グループの移行タスクでは、各 DDL ステートメントで 1 つのテーブルのみに対する操作を行う必要があります。
-   異なるシャード テーブルの DML ステートメントを明確なテーブル スキーマを使用してダウンストリームに移行し、後続のシャーディング DDL ステートメントを正しく一致させて移行できるようにするため、増分レプリケーション タスクの開始時点では各シャード テーブルのテーブル スキーマが同じである必要があります。
-   [テーブルルーティング](/dm/dm-table-routing.md)ルールを変更する必要がある場合は、すべてのシャーディング DDL ステートメントの移行が完了するまで待つ必要があります。
    -   シャーディング DDL ステートメントの移行中に、 `dmctl`使用して`router-rules`変更するとエラーが報告されます。
-   DDL ステートメントが実行されているシャーディング グループに新しいテーブル`CREATE`必要がある場合は、テーブル スキーマが新しく変更されたテーブル スキーマと同じであることを確認する必要があります。
    -   たとえば、元のテーブル`table_1`と`table_2`どちらも最初は 2 つの列 (a、b) を持ち、シャーディング DDL 操作後には 3 つの列 (a、b、c) を持つため、移行後に新しく作成されたテーブルにも 3 つの列 (a、b、c) を持つことになります。
-   DDL ステートメントを受信した DM ワーカーは、他の DM ワーカーが DDL ステートメントを受信するまでタスクを一時停止するため、データ移行の遅延が増加します。

## 背景 {#background}

現在、DMは移行タスクを実行するために`ROW`形式のbinlogを使用しています。このbinlogにはテーブルスキーマ情報は含まれていません。3 `ROW`binlogを使用してデータを移行する場合、複数の上流テーブルを同じ下流テーブルに移行していない限り、下流テーブルのテーブルスキーマを更新できるDDL操作は1つの上流テーブルに対してのみ存在します。5 `ROW`のbinlogは自己記述的な性質を持つと考えられます。移行プロセス中、列値と下流テーブルスキーマに基づいてDML文を作成できます。

ただし、シャードされたテーブルをマージして移行するプロセスで、アップストリーム テーブルで DDL ステートメントを実行してテーブル スキーマを変更する場合は、列値によって生成された DML ステートメントと実際のダウンストリーム テーブル スキーマ間の不整合を回避するために、DDL ステートメントを移行するための追加操作を実行する必要があります。

以下に簡単な例を示します。

![shard-ddl-example-1](/media/dm/shard-ddl-example-1.png)

上記の例では、上流にMySQLインスタンスが2つしか存在せず、各インスタンスにはテーブルが1つしかないため、マージプロセスが簡略化されています。移行開始時に、2つのシャードテーブルのテーブルスキーマバージョンは`schema V1`とマークされ、DDL文実行後のテーブルスキーマバージョンは`schema V2`とマークされます。

ここで、移行プロセスで、2 つの上流のシャード テーブルから受信したbinlogデータが次の時間順序になっていると仮定します。

1.  移行が開始されると、DM ワーカーの同期ユニットは、2 つのシャード テーブルから`schema V1`の DML イベントを受信します。
2.  `t1`では、インスタンス 1 からのシャーディング DDL イベントが受信されます。
3.  `t2`以降、同期ユニットはインスタンス 1 から`schema V2`の DML イベントを受信しますが、インスタンス 2 からは`schema V1`の DML イベントを引き続き受信します。
4.  `t3`では、インスタンス 2 からのシャーディング DDL イベントが受信されます。
5.  `t4`以降、同期ユニットはインスタンス 2 からの DML イベント`schema V2`も受信します。

シャードテーブルのDDL文が移行プロセス中に処理されないと仮定します。インスタンス1のDDL文がダウンストリームに移行された後、ダウンストリームのテーブルスキーマは`schema V2`に変更されます。しかし、インスタンス2では、DMワーカーの同期ユニットが`t2`から`t3`までの間、 `schema V1`のDMLイベントを受信し続けています。そのため、 `schema V1`のDML文がダウンストリームに移行されると、DML文とテーブルスキーマの不整合によりエラーが発生し、データが正常に移行されない可能性があります。

## 原則 {#principles}

このセクションでは、上記の悲観的モードの例に基づいて、DM がシャード テーブルをマージするプロセスで DDL ステートメントを移行する方法を示します。

![shard-ddl-flow](/media/dm/shard-ddl-flow.png)

この例では、 `DM-worker-1` MySQL インスタンス 1 からデータを移行し、 `DM-worker-2` MySQL インスタンス 2 からデータを移行します。5 `DM-master`複数の DM ワーカー間の DDL 移行を調整します。7 `DM-worker-1` DDL 文を受信すると、DDL 移行プロセスは次のように簡略化されます。

1.  `DM-worker-1` 、 `t1`で MySQL インスタンス 1 から DDL ステートメントを受信し、対応する DDL および DML ステートメントのデータ移行を一時停止し、 DDL 情報を`DM-master`に送信します。
2.  `DM-master` 、受信した DDL 情報に基づいてこの DDL ステートメントの移行を調整する必要があることを判断し、この DDL ステートメントのロックを作成し、DDL ロック情報を`DM-worker-1`に送り返し、同時に`DM-worker-1`このロックの所有者としてマークします。
3.  `DM-worker-2` 、 `t3`で MySQL インスタンス 2 から DDL ステートメントを受信するまで DML ステートメントの移行を継続し、この DDL ステートメントのデータ移行を一時停止し、 DDL 情報を`DM-master`に送信します。
4.  `DM-master` 、受信した DDL 情報に基づいて、この DDL ステートメントのロックがすでに存在すると判断し、ロック情報を直接`DM-worker-2`に送信します。
5.  タスク開始時の設定情報、上流MySQLインスタンス内のシャードテーブル情報、デプロイメントトポロジ情報に基づいて、 `DM-master` 、マージ対象となる上流シャードテーブルすべてのこのDDL文を受信したと判断し、DDLロックの所有者（ `DM-worker-1` ）にこのDDL文を下流に移行するように要求します。
6.  `DM-worker-1` 、ステップ 2 で受信した DDL ロック情報に基づいて DDL 文の実行要求を検証し、この DDL 文を下流へ移行し、その結果を`DM-master`に送信します。この操作が成功した場合、 `DM-worker-1`後続の DDL 文（binlogの`t2`から開始）の移行を継続します。
7.  `DM-master`ロック所有者からDDLが正常に実行されたという応答を受け取り、DDLロックを待機している他のすべてのDMワーカー（ `DM-worker-2` ）にこのDDL文を無視して、後続の（binlogの`t4`から始まる）DML文の移行を続行するように要求します。

複数の DM ワーカー間でのシャーディング DDL 移行を処理する DM の特性は、次のようにまとめられます。

-   タスク構成とDMクラスタのデプロイメントトポロジ情報に基づいて、DDL移行を調整するための論理シャーディンググループが`DM-master`に構築されます。グループメンバーは、移行タスクから分割された各サブタスクを処理するDMワーカーです。
-   各 DM ワーカーは、 binlogイベントから DDL ステートメントを受信すると、DDL 情報を`DM-master`に送信します。
-   `DM-master` 、各 DM ワーカーから受信した DDL 情報とシャーディング グループ情報に基づいて DDL ロックを作成または更新します。
-   シャーディンググループの全メンバーが同じ特定のDDL文を受け取った場合、上流のシャードテーブルにおけるDDL実行前のすべてのDML文が完全に移行されており、このDDL文を実行できることを示します。その後、DMは後続のDML文の移行を続行できます。
-   [テーブルルーター](/dm/dm-table-routing.md)によって変換された後、上流のシャードテーブルのDDL文は、下流で実行されるDDL文と一致している必要があります。したがって、このDDL文はDDL所有者によって一度だけ実行され、他のすべてのDMワーカーはこのDDL文を無視できます。

上記の例では、各DMワーカーに対応する上流MySQLインスタンスでマージする必要があるシャードテーブルは1つだけです。しかし、実際のシナリオでは、複数のシャードスキーマにある複数のシャードテーブルを1つのMySQLインスタンスにマージする必要がある場合があります。このような場合、シャーディングDDLの移行の調整はより複雑になります。

1 つの MySQL インスタンスにマージされる 2 つのシャード テーブル ( `table_1`と`table_2` ) があるとします。

![shard-ddl-example-2](/media/dm/shard-ddl-example-2.png)

データは同じMySQLインスタンスから取得されるため、すべてのデータは同じbinlogストリームから取得されます。この場合、時系列は次のようになります。

1.  移行が開始されると、DM ワーカーの同期ユニットは、両方のシャード テーブルから`schema V1`の DML ステートメントを受け取ります。
2.  `t1`では、 DM ワーカーの同期ユニットが`table_1`の DDL ステートメントを受信します。
3.  `t2`から`t3`まで、受信データには`table_1`から`schema V2`の DML 文と`table_2`から`schema V1`の DML 文が含まれます。
4.  `t3`では、 DM ワーカーの同期ユニットが`table_2`の DDL ステートメントを受信します。
5.  `t4`以降、DM ワーカーの同期ユニットは、両方のテーブルから`schema V2`の DML ステートメントを受信します。

データ移行中にDDL文が適切に処理されない場合、 `table_1`のDDL文が下流に移行され、下流のテーブルスキーマを変更すると、 `table_2`から`schema V1`のDML文が正常に移行されません。そのため、単一のDMワーカー内に、 `DM-master`同様の論理シャーディンググループが作成されます。ただし、このグループのメンバーは、同じ上流MySQLインスタンス内の異なるシャーディングテーブルです。

しかし、DMワーカーがシャーディンググループの移行を自身内で調整する場合、それは`DM-master`によって実行されるものと完全に同じではありません。その理由は次のとおりです。

-   DMワーカーが`table_1`のDDL文を受信すると、マイグレーションを一時停止することができず、 `table_2`後続のDDL文を取得するためにbinlogの解析を継続する必要があります。つまり、 `t2`と`t3`間の解析を継続する必要があるということです。
-   `t2`から`t3`間のbinlog解析プロセス中、シャーディング DDL ステートメントが移行されて正常に実行されるまで、 `table_1`の`schema V2`の DML ステートメントはダウンストリームに移行できません。

DM では、DM ワーカー内での DDL ステートメントのシャーディングの簡略化された移行プロセスは次のとおりです。

1.  `t1`で`table_1`の DDL 文を受信すると、 DM ワーカーは DDL 情報とbinlogの現在の位置を記録します。
2.  DM-worker は`t2`から`t3`間のbinlog の解析を続行します。
3.  DM-worker は、 `table_1`に属する`schema V2`スキーマの DML ステートメントを無視し、 `table_2`に属する`schema V1`スキーマの DML ステートメントを下流に移行します。
4.  `t3`で`table_2`の DDL 文を受信すると、 DM ワーカーは DDL 情報とbinlogの現在の位置を記録します。
5.  移行タスク構成と上流のスキーマおよびテーブルの情報に基づいて、DM ワーカーは、MySQL インスタンス内のすべてのシャード テーブルの DDL ステートメントが受信されたことを判断し、それらを下流に移行して下流のテーブル スキーマを変更します。
6.  DM-worker は、新しいbinlogストリームの解析の開始点を、ステップ 1 で保存された位置に設定します。
7.  DM-worker は`t2`から`t3`間のbinlog の解析を再開します。
8.  DM-worker は、 `table_1`に属する`schema V2`スキーマの DML 文を下流に移行し、 `table_2`に属する`schema V1`スキーマの DML 文を無視します。
9.  ステップ 4 で保存されたbinlog の位置を解析した後、DM ワーカーは、ステップ 3 で無視されたすべての DML ステートメントがダウンストリームに再度移行されたと判断します。
10. DM-worker は、 binlog の位置`t4`から移行を再開します。

上記の分析から、DMはシャーディングDDLの移行処理において、主に2階層のシャーディンググループを調整と制御に使用していることがわかります。簡略化したプロセスは以下のとおりです。

1.  各 DM ワーカーは、アップストリーム MySQL インスタンス内の複数のシャード テーブルで構成される対応するシャーディング グループの DDL ステートメントの移行を個別に調整します。
2.  DM ワーカーは、すべてのシャード テーブルの DDL ステートメントを受信すると、DDL 情報を`DM-master`に送信します。
3.  `DM-master` 、受信した DDL 情報に基づいて、DM ワーカーで構成されたシャーディング グループの DDL 移行を調整します。
4.  すべての DM ワーカーから DDL 情報を受信した後、DDL ロック所有者 (特定の DM ワーカー) `DM-master` DDL ステートメントの実行を要求します。
5.  DDLロック所有者はDDL文を実行し、結果を`DM-master`に返します。その後、所有者はDDL移行の内部調整中に、以前無視されていたDML文の移行を再開します。
6.  `DM-master` 、所有者が DDL ステートメントを正常に実行したことを確認した後、他のすべての DM ワーカーに移行を続行するよう要求します。
7.  他のすべての DM ワーカーは、DDL 移行の内部調整中に、以前に無視された DML ステートメントの移行を個別に再開します。
8.  無視された DML ステートメントの移行が再度完了すると、すべての DM ワーカーは通常の移行プロセスを再開します。
